# Домашнее задание к лекции 2. «Iterators. Generators. Yield»

## Описание

Реализация итераторов и генераторов для преобразования вложенных списков в плоскую последовательность.

## Задания

### Задание 1: FlatIterator (базовый)
Итератор для списка списков (один уровень вложенности).

**Файл:** `task_1.py`

**Особенность:** итератор одноразовый — курсоры инициализируются в `__init__`, а не в `__iter__`. Для повторного обхода нужно создать новый экземпляр класса.

**Пример:**
```python
list_of_lists = [['a', 'b'], ['c', 'd']]
# Результат: ['a', 'b', 'c', 'd']
```

### Задание 2: flat_generator (базовый)
Генератор для списка списков (один уровень вложенности).

**Файл:** `task_2.py`

**Преимущества генератора:**
- Более компактный код
- Меньше потребление памяти
- Ленивое вычисление

### Задание 3: FlatIterator (продвинутый) ✨
Итератор для произвольных вложенных итерируемых объектов (list, tuple, set и др.).

**Файл:** `task_3.py`

**Реализация:** использует стек для обхода вложенных структур. Проверка итерируемости через `collections.abc.Iterable` вместо привязки к конкретному типу `list` (строки и байты исключены).

**Пример:**
```python
nested = [((('a',),), 'b'), {1, 2}, [['c']]]
# Результат: ['a', 'b', 1, 2, 'c']
```

### Задание 4: flat_generator (продвинутый) ✨
Генератор для произвольных вложенных итерируемых объектов (list, tuple, set и др.).

**Файл:** `task_4.py`

**Реализация:** использует рекурсию и `yield from`. Проверка итерируемости через `collections.abc.Iterable` (строки и байты исключены).

## Запуск

Каждое задание можно запустить отдельно:

```bash
cd homework-4

# Задание 1
python task_1.py

# Задание 2
python task_2.py

# Задание 3
python task_3.py

# Задание 4
python task_4.py
```

## Ключевые концепции

### Итератор vs Генератор

**Итератор:**
- Класс с методами `__iter__()` и `__next__()`
- Полный контроль над процессом итерации
- Может иметь дополнительные методы и атрибуты
- Подходит для сложных структур данных

**Генератор:**
- Функция с ключевым словом `yield`
- Более компактный код
- Автоматическое управление состоянием
- Подходит для простых случаев

### Одноразовый итератор (Задание 1)
```python
# Курсоры в __init__ — стандартный подход Python
it = FlatIterator(data)
list(it)  # ['a', 'b', 'c']
list(it)  # [] — итератор исчерпан
```

### Использование стека (Задание 3)
```python
self.stack = [iter(self.list_of_list)]
# Добавляем новые итераторы при встрече вложенных Iterable
# Удаляем исчерпанные итераторы
```

### Универсальная проверка итерируемости (Задания 3 и 4)
```python
from collections.abc import Iterable

# Вместо isinstance(item, list) — поддержка любых итерируемых типов
if isinstance(item, Iterable) and not isinstance(item, (str, bytes)):
    ...
```

### Использование yield from (Задание 4)
```python
yield from flat_generator(item)  # Делегирование другому генератору
```

## Соответствие стандартам

Код оформлен согласно:
- [PEP 8 — Style Guide for Python Code](https://peps.python.org/pep-0008/)
- [Руководству Netology по оформлению Python-кода](https://github.com/netology-code/codestyle/tree/master/python)

## Тестирование

Все задания включают тестовые функции, которые проверяют:
- Корректность результата
- Соответствие типов (для генераторов)
- Работу с различными типами данных (str, int, bool, None)
- Одноразовость итератора (задание 1)
- Поддержку tuple, set и смешанных структур (задания 3, 4)
